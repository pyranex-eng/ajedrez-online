<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ajedrez Online - Juego</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        body {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: #fff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 20px;
        }
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 1200px;
            margin-bottom: 20px;
        }
        header h1 {
            font-size: 2.5rem;
            color: #e94560;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .room-info {
            font-size: 1.2rem;
            display: flex;
            align-items: center;
        }
        #connection-status {
            font-size: 0.9rem;
            font-weight: bold;
        }
        .btn {
            background-color: #e94560;
            color: #fff;
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .btn:hover {
            background-color: #ff6a80;
        }
        .btn-leave {
            background-color: #7289da;
        }
        .btn-leave:hover {
            background-color: #5b6fb8;
        }
        .game-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 40px;
            width: 100%;
            flex-wrap: wrap;
        }
        .chess-board-container {
            background-color: #3e3e60;
            padding: 15px;
            border-radius: 15px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            display: inline-block;
        }
        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            border: 2px solid #555;
            position: relative;
        }
        .square {
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            user-select: none;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .square.light {
            background-color: #f0d9b5;
        }
        .square.dark {
            background-color: #b58863;
        }
        .piece {
            font-size: 45px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
            cursor: grab;
            transition: transform 0.1s ease;
        }
        .piece.white {
            color: #fff;
        }
        .piece.black {
            color: #000;
        }
        .square.selected {
            background-color: rgba(233, 69, 96, 0.7);
        }
        .square.possible-move {
            background-color: rgba(255, 238, 0, 0.5);
            border: 2px solid rgba(255, 238, 0, 0.8);
        }
        .file-label, .rank-label {
            position: absolute;
            font-size: 12px;
            color: #555;
            font-weight: bold;
            text-transform: uppercase;
        }
        .file-label {
            bottom: 2px;
            right: 2px;
        }
        .rank-label {
            top: 2px;
            left: 2px;
        }
        .game-info {
            background-color: #2b2b48;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            width: 100%;
            max-width: 350px;
        }
        .players-info {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
        }
        .player {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 10px;
            background-color: #3e3e60;
            border-radius: 10px;
        }
        .player-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: #555;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }
        .player-info {
            flex-grow: 1;
        }
        .player-name {
            font-size: 1.2rem;
            font-weight: bold;
        }
        .player-status {
            font-size: 0.9rem;
            color: #ccc;
        }
        .player-online-status {
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            gap: 5px;
            font-weight: bold;
        }
        .turn-indicator {
            text-align: center;
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 20px;
        }
        .status-message {
            text-align: center;
            font-size: 1.5rem;
            font-weight: bold;
            color: #ffcc00;
            margin-bottom: 20px;
        }
        .captured-pieces {
            margin-bottom: 20px;
        }
        .captured-pieces h3 {
            font-size: 1.1rem;
            margin-bottom: 10px;
            color: #e94560;
        }
        .captured-pieces-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            min-height: 30px;
        }
        .captured-piece {
            font-size: 20px;
            opacity: 0.7;
        }
        .captured-piece.white {
            color: #fff;
        }
        .captured-piece.black {
            color: #000;
        }
        .game-controls {
            display: flex;
            justify-content: space-around;
            gap: 10px;
        }
        .promotion-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        .promotion-options {
            background-color: #2b2b48;
            padding: 20px;
            border-radius: 10px;
            display: flex;
            gap: 15px;
        }
        .promotion-option {
            font-size: 40px;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.2s ease;
        }
        .promotion-option:hover {
            background-color: #e94560;
            transform: scale(1.1);
        }
        .promotion-option.white {
            color: #fff;
        }
        .promotion-option.black {
            color: #000;
        }
/* Tamaño aumentado para PC (pantallas mayores a 768px) */
@media (min-width: 768px) {
    .chess-board {
        grid-template-columns: repeat(8, 70px);
        grid-template-rows: repeat(8, 70px);
    }
    .square {
        width: 70px;
        height: 70px;
    }
    .piece {
        font-size: 50px;
    }
}

/* Tamaño extra grande para pantallas muy grandes (opcional) */
@media (min-width: 1200px) {
    .chess-board {
        grid-template-columns: repeat(8, 80px);
        grid-template-rows: repeat(8, 80px);
    }
    .square {
        width: 80px;
        height: 80px;
    }
    .piece {
        font-size: 60px;
    }
}
    </style>
</head>
<body>
    <header>
        <h1><i class="fas fa-chess-board"></i> Ajedrez Online</h1>
        <div class="room-info">
            <span id="room-name-display">Sala: </span>
            <span id="connection-status" style="margin-left: 15px; padding: 4px 8px; border-radius: 4px; background-color: #4CAF50;">
                Conectado
            </span>
        </div>
        <button class="btn btn-leave" id="leave-btn">Abandonar Sala</button>
    </header>

    <div class="game-container">
        <div class="chess-board-container">
            <div class="chess-board" id="chess-board"></div>
        </div>
        
        <div class="game-info">
            <div class="players-info">
                <div class="player" id="white-player">
                    <div class="player-avatar" id="white-avatar"><i class="fas fa-user"></i></div>
                    <div class="player-info">
                        <div class="player-name" id="white-name">Esperando jugador...</div>
                        <div class="player-status">Blancas</div>
                    </div>
                    <div class="player-online-status" id="white-online"></div>
                </div>
                
                <div class="player" id="black-player">
                    <div class="player-avatar" id="black-avatar"><i class="fas fa-user"></i></div>
                    <div class="player-info">
                        <div class="player-name" id="black-name">Esperando jugador...</div>
                        <div class="player-status">Negras</div>
                    </div>
                    <div class="player-online-status" id="black-online"></div>
                </div>
            </div>
            
            <div class="turn-indicator" id="turn-indicator">
                Turno de: <span id="current-turn">...</span>
            </div>
            
            <div id="game-status" class="status-message" style="display: none;"></div>
            
            <div class="captured-pieces">
                <h3>Piezas capturadas (Blancas):</h3>
                <div class="captured-pieces-list" id="white-captured"></div>
            </div>
            
            <div class="captured-pieces">
                <h3>Piezas capturadas (Negras):</h3>
                <div class="captured-pieces-list" id="black-captured"></div>
            </div>
            
            <div class="game-controls">
                <button class="btn" id="offer-draw-btn">Ofrecer tablas</button>
                <button class="btn" id="resign-btn">Rendirse</button>
            </div>
        </div>
    </div>

    <div class="promotion-modal" id="promotion-modal">
        <div class="promotion-options" id="promotion-options"></div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>

    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyAELxl8vQ3hea6OaD1pwZaoIDUrxY07vwg",
            authDomain: "ajedrez-online-9da63.firebaseapp.com",
            databaseURL: "https://ajedrez-online-9da63-default-rtdb.firebaseio.com",
            projectId: "ajedrez-online-9da63",
            storageBucket: "ajedrez-online-9da63.firebasestorage.app",
            messagingSenderId: "841079328346",
            appId: "1:841079328346:web:2a2f66f352ee8932ad9263",
            measurementId: "G-ML6HGX08LE"
        };
        firebase.initializeApp(firebaseConfig);

    const auth = firebase.auth();
    const database = firebase.database();
    const urlParams = new URLSearchParams(window.location.search);
    const roomKey = urlParams.get('room');
    if (!roomKey) {
        window.location.href = 'salas.html';
    }

    const roomRef = database.ref('rooms/' + roomKey);
    let playerColor = null;
    let gameState = null;
    let selectedPiece = null;
    let turn = null;
    let gameInfo = null;

    const board = document.getElementById('board');
    const playerTurnIndicator = document.getElementById('player-turn');
    const opponentNameElement = document.getElementById('opponent-name');
    const playerColorIndicator = document.getElementById('player-color');
    const whiteCapturedList = document.getElementById('white-captured-pieces');
    const blackCapturedList = document.getElementById('black-captured-pieces');
    const gameStatusMessage = document.getElementById('game-status-message');
    const resignBtn = document.getElementById('resign-btn');
    const offerDrawBtn = document.getElementById('offer-draw-btn');
    const leaveBtn = document.getElementById('leave-btn');

    const pieceSymbols = {
        'wp': '♟︎', 'wn': '♞', 'wb': '♝', 'wr': '♜', 'wq': '♛', 'wk': '♚',
        'bp': '♙', 'bn': '♘', 'bb': '♗', 'br': '♖', 'bq': '♕', 'bk': '♔'
    };

    auth.onAuthStateChanged(user => {
        if (!user) {
            window.location.href = 'login-registro.html';
            return;
        }

        roomRef.once('value', snapshot => {
            const roomData = snapshot.val();
            if (!roomData) {
                alert('La sala ya no existe.');
                window.location.href = 'salas.html';
                return;
            }

            const isPlayer1 = roomData.players.player1 === user.uid;
            const isPlayer2 = roomData.players.player2 === user.uid;

            if (!isPlayer1 && !isPlayer2) {
                alert('No tienes permiso para unirte a esta sala.');
                window.location.href = 'salas.html';
                return;
            }

            if (isPlayer1) {
                playerColor = 'white';
            } else {
                playerColor = 'black';
            }

            playerColorIndicator.textContent = `Eres el jugador: ${playerColor.charAt(0).toUpperCase() + playerColor.slice(1)}`;

            roomRef.on('value', snapshot => {
                const updatedRoomData = snapshot.val();
                if (!updatedRoomData) {
                    return;
                }
                gameState = updatedRoomData.gameState;
                turn = updatedRoomData.gameInfo.turn;
                gameInfo = updatedRoomData.gameInfo;
                updateGameDisplay(updatedRoomData);
            });
        });
    });

    board.addEventListener('click', handleSquareClick);

    function updateGameDisplay(roomData) {
        drawBoard(roomData.gameState);
        updateCapturedPieces(roomData.gameInfo);
        updateTurnIndicator(roomData.gameInfo.turn);
        updateGameStatus(roomData.gameInfo);
        updateOpponentName(roomData);
    }

    function drawBoard(boardState) {
        board.innerHTML = '';
        const isWhitePlayer = playerColor === 'white';
        for (let i = 0; i < 8; i++) {
            const row = isWhitePlayer ? i : 7 - i;
            const rowElement = document.createElement('div');
            rowElement.classList.add('board-row');
            for (let j = 0; j < 8; j++) {
                const col = isWhitePlayer ? j : 7 - j;
                const square = document.createElement('div');
                square.classList.add('square');
                square.classList.add((row + col) % 2 === 0 ? 'light' : 'dark');
                square.dataset.row = row;
                square.dataset.col = col;

                const piece = boardState[row][col];
                if (piece) {
                    const pieceSymbol = pieceSymbols[piece] || '';
                    square.innerHTML = pieceSymbol;
                    square.classList.add('piece');
                    square.classList.add(piece[0] === 'w' ? 'white-piece' : 'black-piece');
                }
                rowElement.appendChild(square);
            }
            board.appendChild(rowElement);
        }
    }

    function handleSquareClick(event) {
        if (gameInfo.status !== 'playing' || turn !== playerColor) {
            return;
        }

        const square = event.target.closest('.square');
        if (!square) return;

        const row = parseInt(square.dataset.row);
        const col = parseInt(square.dataset.col);

        if (selectedPiece) {
            const [selectedRow, selectedCol] = selectedPiece;
            const pieceToMove = gameState[selectedRow][selectedCol];
            const possibleMoves = getPossibleMoves(selectedRow, selectedCol);
            const move = possibleMoves.find(m => m.row === row && m.col === col);
            
            if (move) {
                makeMove(selectedRow, selectedCol, row, col, move.isCastling);
            }
            selectedPiece = null;
            clearHighlights();
        } else {
            const piece = gameState[row][col];
            if (piece && piece[0] === playerColor[0]) {
                selectedPiece = [row, col];
                highlightMoves(row, col);
            }
        }
    }

    function makeMove(fromRow, fromCol, toRow, toCol, isCastling = false) {
        const pieceToMove = gameState[fromRow][fromCol];
        const newGameState = JSON.parse(JSON.stringify(gameState));
        const capturedPiece = newGameState[toRow][toCol];

        if (isCastling === 'kingSide') {
            newGameState[fromRow][fromCol+2] = pieceToMove;
            newGameState[fromRow][fromCol] = null;
            newGameState[fromRow][fromCol+1] = newGameState[fromRow][fromCol+3];
            newGameState[fromRow][fromCol+3] = null;
        } else if (isCastling === 'queenSide') {
            newGameState[fromRow][fromCol-2] = pieceToMove;
            newGameState[fromRow][fromCol] = null;
            newGameState[fromRow][fromCol-1] = newGameState[fromRow][fromCol-4];
            newGameState[fromRow][fromCol-4] = null;
        } else {
            newGameState[toRow][toCol] = pieceToMove;
            newGameState[fromRow][fromCol] = null;

            // Handle en passant capture
            if (pieceToMove[1] === 'p' && gameInfo.enPassantTarget && 
                toRow === gameInfo.enPassantTarget.row && toCol === gameInfo.enPassantTarget.col) {
                const capturedPawnRow = playerColor === 'white' ? toRow + 1 : toRow - 1;
                gameInfo.whiteCaptured = gameInfo.whiteCaptured || [];
                gameInfo.blackCaptured = gameInfo.blackCaptured || [];
                if (playerColor === 'white') {
                    gameInfo.blackCaptured.push(newGameState[capturedPawnRow][toCol]);
                } else {
                    gameInfo.whiteCaptured.push(newGameState[capturedPawnRow][toCol]);
                }
                newGameState[capturedPawnRow][toCol] = null;
            }
        }
        
        const updates = {
            'gameState': newGameState,
            'gameInfo/turn': playerColor === 'white' ? 'black' : 'white',
            'gameInfo/lastMove': {
                from: { row: fromRow, col: fromCol },
                to: { row: toRow, col: toCol }
            }
        };

        // Pawn promotion logic
        if (pieceToMove[1] === 'p' && (toRow === 0 || toRow === 7)) {
            newGameState[toRow][toCol] = playerColor === 'white' ? 'wq' : 'bq';
        }

        // Handle castling rights
        if (pieceToMove[1] === 'k') {
            if (playerColor === 'white') {
                updates['gameInfo/canWhiteKingSideCastle'] = false;
                updates['gameInfo/canWhiteQueenSideCastle'] = false;
            } else {
                updates['gameInfo/canBlackKingSideCastle'] = false;
                updates['gameInfo/canBlackQueenSideCastle'] = false;
            }
        } else if (pieceToMove[1] === 'r') {
            if (playerColor === 'white' && fromRow === 7) {
                if (fromCol === 0) updates['gameInfo/canWhiteQueenSideCastle'] = false;
                if (fromCol === 7) updates['gameInfo/canWhiteKingSideCastle'] = false;
            } else if (playerColor === 'black' && fromRow === 0) {
                if (fromCol === 0) updates['gameInfo/canBlackQueenSideCastle'] = false;
                if (fromCol === 7) updates['gameInfo/canBlackKingSideCastle'] = false;
            }
        }
        
        // Handle en passant target
        if (pieceToMove[1] === 'p' && Math.abs(fromRow - toRow) === 2) {
            updates['gameInfo/enPassantTarget'] = { row: fromRow + (toRow - fromRow) / 2, col: toCol };
        } else {
            updates['gameInfo/enPassantTarget'] = null;
        }

        // Add captured piece to the list
        if (capturedPiece) {
            updates['gameInfo/' + (playerColor === 'white' ? 'whiteCaptured' : 'blackCaptured')] = 
                (gameInfo[playerColor === 'white' ? 'whiteCaptured' : 'blackCaptured'] || []).concat(capturedPiece);
        }

        const opponentKingColor = playerColor === 'white' ? 'b' : 'w';
        const opponentKingPos = findKing(newGameState, opponentKingColor);

        if (isSquareAttacked(opponentKingPos.row, opponentKingPos.col, newGameState, playerColor[0])) {
            updates['gameInfo/isCheck'] = true;
            if (!getLegalMovesForPlayer(newGameState, opponentColor)) {
                updates['gameInfo/status'] = 'finished';
                updates['gameInfo/winner'] = playerColor;
                updates['gameInfo/isCheckmate'] = true;
            }
        } else {
            updates['gameInfo/isCheck'] = false;
            if (!getLegalMovesForPlayer(newGameState, opponentColor)) {
                updates['gameInfo/status'] = 'finished';
                updates['gameInfo/isStalemate'] = true;
            }
        }

        roomRef.update(updates).catch(error => console.error("Error al realizar el movimiento:", error));
    }

    function highlightMoves(row, col) {
        clearHighlights();
        const piece = gameState[row][col];
        if (!piece) return;

        const possibleMoves = getPossibleMoves(row, col);
        const playerIsWhite = playerColor === 'white';
        
        const pieceSquare = document.querySelector(`[data-row='${row}'][data-col='${col}']`);
        if (pieceSquare) pieceSquare.classList.add('selected');

        possibleMoves.forEach(move => {
            const targetSquare = document.querySelector(`[data-row='${move.row}'][data-col='${move.col}']`);
            if (targetSquare) {
                targetSquare.classList.add('highlight');
                if (gameState[move.row][move.col]) {
                    targetSquare.classList.add('capture-highlight');
                }
            }
        });
    }

    function clearHighlights() {
        document.querySelectorAll('.highlight, .selected, .capture-highlight').forEach(el => {
            el.classList.remove('highlight', 'selected', 'capture-highlight');
        });
    }

    function getPossibleMoves(row, col) {
        const moves = getPseudoLegalMoves(row, col, gameState);
        const legalMoves = moves.filter(move => {
            return !isMovePuttingKingInCheck(row, col, move.row, move.col, move.isCastling);
        });
        return legalMoves;
    }

    function findKing(board, color) {
        const kingPiece = color === 'w' ? 'wk' : 'bk';
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                if (board[r][c] === kingPiece) {
                    return { row: r, col: c };
                }
            }
        }
        return null;
    }

    function isKingInCheck(board, color) {
        const kingPos = findKing(board, color);
        if (!kingPos) return false;
        const opponentColor = color === 'w' ? 'b' : 'w';
        return isSquareAttacked(kingPos.row, kingPos.col, board, opponentColor);
    }

    function isCheckmate(board, color) {
        if (!isKingInCheck(board, color)) {
            return false;
        }
        return !getLegalMovesForPlayer(board, color);
    }
    
    // NUEVAS FUNCIONES CORREGIDAS
    function isMovePuttingKingInCheck(fromRow, fromCol, toRow, toCol, isCastling = false) {
        const tempBoard = JSON.parse(JSON.stringify(gameState));
        const pieceToMove = tempBoard[fromRow][fromCol];
        const playerKingColor = pieceToMove[0];
        const opponentColor = playerKingColor === 'w' ? 'b' : 'w';
        
        if (isCastling === 'kingSide') {
            tempBoard[fromRow][fromCol+2] = pieceToMove;
            tempBoard[fromRow][fromCol] = null;
            tempBoard[fromRow][fromCol+1] = tempBoard[fromRow][fromCol+3];
            tempBoard[fromRow][fromCol+3] = null;
        } else if (isCastling === 'queenSide') {
            tempBoard[fromRow][fromCol-2] = pieceToMove;
            tempBoard[fromRow][fromCol] = null;
            tempBoard[fromRow][fromCol-1] = tempBoard[fromRow][fromCol-4];
            tempBoard[fromRow][fromCol-4] = null;
        } else {
            const capturedPiece = tempBoard[toRow][toCol];
            tempBoard[toRow][toCol] = pieceToMove;
            tempBoard[fromRow][fromCol] = null;
            
            if (pieceToMove[1] === 'p' && gameInfo.enPassantTarget && 
                toRow === gameInfo.enPassantTarget.row && toCol === gameInfo.enPassantTarget.col) {
                const capturedPawnRow = playerKingColor === 'w' ? toRow + 1 : toRow - 1;
                tempBoard[capturedPawnRow][toCol] = null;
            }
        }
        
        const kingPos = findKing(tempBoard, playerKingColor);
        if (!kingPos) {
            return true; 
        }

        return isSquareAttacked(kingPos.row, kingPos.col, tempBoard, opponentColor);
    }

    function getLegalMovesForPlayer(board, color) {
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const piece = board[r][c];
                if (piece && piece[0] === color) {
                    const moves = getPseudoLegalMoves(r, c, board);
                    const legalMoves = moves.filter(move => {
                        return !isMovePuttingKingInCheck(r, c, move.row, move.col, move.isCastling);
                    });
                    if (legalMoves.length > 0) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    function isSquareAttacked(row, col, board, attackingColor) {
        // 1. Revisar por peones
        const pawnDirection = attackingColor === 'w' ? 1 : -1;
        if (row + pawnDirection >= 0 && row + pawnDirection < 8) {
            if (col - 1 >= 0 && board[row + pawnDirection][col - 1] === attackingColor + 'p') return true;
            if (col + 1 < 8 && board[row + pawnDirection][col + 1] === attackingColor + 'p') return true;
        }
        // 2. Revisar por caballeros
        const knightMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
        for (const [dr, dc] of knightMoves) {
            const r = row + dr;
            const c = col + dc;
            if (r >= 0 && r < 8 && c >= 0 && c < 8 && board[r][c] === attackingColor + 'n') return true;
        }
        // 3. Revisar por torres y reinas (movimientos rectos)
        const straightDirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];
        for (const [dr, dc] of straightDirs) {
            let r = row + dr;
            let c = col + dc;
            while (r >= 0 && r < 8 && c >= 0 && c < 8) {
                const piece = board[r][c];
                if (piece) {
                    if (piece[0] === attackingColor && (piece[1] === 'r' || piece[1] === 'q')) return true;
                    break;
                }
                r += dr;
                c += dc;
            }
        }
        // 4. Revisar por alfiles y reinas (movimientos diagonales)
        const diagonalDirs = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
        for (const [dr, dc] of diagonalDirs) {
            let r = row + dr;
            let c = col + dc;
            while (r >= 0 && r < 8 && c >= 0 && c < 8) {
                const piece = board[r][c];
                if (piece) {
                    if (piece[0] === attackingColor && (piece[1] === 'b' || piece[1] === 'q')) return true;
                    break;
                }
                r += dr;
                c += dc;
            }
        }
        // 5. Revisar por el rey (para movimientos de un paso)
        const kingMoves = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
        for (const [dr, dc] of kingMoves) {
            const r = row + dr;
            const c = col + dc;
            if (r >= 0 && r < 8 && c >= 0 && c < 8 && board[r][c] === attackingColor + 'k') return true;
        }
        return false;
    }

    function getPseudoLegalMoves(row, col, board) {
        const moves = [];
        const piece = board[row][col];
        if (!piece) return moves;

        const type = piece[1];
        const color = piece[0];

        // Lógica para el peón
        if (type === 'p') {
            const direction = color === 'w' ? -1 : 1;
            const startRow = color === 'w' ? 6 : 1;
            if (row + direction >= 0 && row + direction < 8 && !board[row + direction][col]) {
                moves.push({row: row + direction, col: col});
                if (row === startRow && !board[row + 2 * direction][col]) {
                    moves.push({row: row + 2 * direction, col: col});
                }
            }
            for (let offset of [-1, 1]) {
                if (col + offset >= 0 && col + offset < 8) {
                    const targetPiece = board[row + direction][col + offset];
                    if (targetPiece && targetPiece[0] !== color) {
                        moves.push({row: row + direction, col: col + offset});
                    }
                }
            }
        }

        // Lógica para la torre y la reina
        if (type === 'r' || type === 'q') {
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            for (let [dr, dc] of directions) {
                let r = row + dr;
                let c = col + dc;
                while (r >= 0 && r < 8 && c >= 0 && c < 8) {
                    const targetPiece = board[r][c];
                    if (!targetPiece) {
                        moves.push({row: r, col: c});
                    } else {
                        if (targetPiece[0] !== color) {
                            moves.push({row: r, col: c});
                        }
                        break;
                    }
                    r += dr;
                    c += dc;
                }
            }
        }
        // Lógica para el alfil y la reina
        if (type === 'b' || type === 'q') {
            const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
            for (let [dr, dc] of directions) {
                let r = row + dr;
                let c = col + dc;
                while (r >= 0 && r < 8 && c >= 0 && c < 8) {
                    const targetPiece = board[r][c];
                    if (!targetPiece) {
                        moves.push({row: r, col: c});
                    } else {
                        if (targetPiece[0] !== color) {
                            moves.push({row: r, col: c});
                        }
                        break;
                    }
                    r += dr;
                    c += dc;
                }
            }
        }
        // Lógica para el caballo
        if (type === 'n') {
            const knightMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
            for (const [dr, dc] of knightMoves) {
                const r = row + dr;
                const c = col + dc;
                if (r >= 0 && r < 8 && c >= 0 && c < 8) {
                    const targetPiece = board[r][c];
                    if (!targetPiece || targetPiece[0] !== color) {
                        moves.push({row: r, col: c});
                    }
                }
            }
        }
        // Lógica para el rey
        if (type === 'k') {
            const kingMoves = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
            for (const [dr, dc] of kingMoves) {
                const r = row + dr;
                const c = col + dc;
                if (r >= 0 && r < 8 && c >= 0 && c < 8) {
                    const targetPiece = board[r][c];
                    if (!targetPiece || targetPiece[0] !== color) {
                        moves.push({row: r, col: c});
                    }
                }
            }
        }
        // Lógica para el enroque
        if (type === 'k') {
            if (color === 'w') {
                if (gameInfo.canWhiteKingSideCastle && !board[7][5] && !board[7][6] && 
                    !isSquareAttacked(7, 4, board, 'b') && !isSquareAttacked(7, 5, board, 'b') && !isSquareAttacked(7, 6, board, 'b')) {
                    moves.push({row: 7, col: 6, isCastling: 'kingSide'});
                }
                if (gameInfo.canWhiteQueenSideCastle && !board[7][1] && !board[7][2] && !board[7][3] && 
                    !isSquareAttacked(7, 4, board, 'b') && !isSquareAttacked(7, 3, board, 'b') && !isSquareAttacked(7, 2, board, 'b')) {
                    moves.push({row: 7, col: 2, isCastling: 'queenSide'});
                }
            } else {
                if (gameInfo.canBlackKingSideCastle && !board[0][5] && !board[0][6] && 
                    !isSquareAttacked(0, 4, board, 'w') && !isSquareAttacked(0, 5, board, 'w') && !isSquareAttacked(0, 6, board, 'w')) {
                    moves.push({row: 0, col: 6, isCastling: 'kingSide'});
                }
                if (gameInfo.canBlackQueenSideCastle && !board[0][1] && !board[0][2] && !board[0][3] && 
                    !isSquareAttacked(0, 4, board, 'w') && !isSquareAttacked(0, 3, board, 'w') && !isSquareAttacked(0, 2, board, 'w')) {
                    moves.push({row: 0, col: 2, isCastling: 'queenSide'});
                }
            }
        }

        return moves;
    }
    
    function updateTurnIndicator(currentTurn) {
        playerTurnIndicator.textContent = `Turno: ${currentTurn === 'white' ? 'Blanco' : 'Negro'}`;
    }

    function updateGameStatus(info) {
        let message = '';
        if (info.status === 'finished') {
            if (info.isCheckmate) {
                message = `¡Jaque Mate! ${info.winner === 'white' ? 'Blanco' : 'Negro'} ha ganado.`;
            } else if (info.isStalemate) {
                message = '¡Ahogado! El juego es un empate.';
            } else if (info.winner) {
                message = `¡Juego Terminado! ${info.winner === 'white' ? 'Blanco' : 'Negro'} ha ganado.`;
            } else {
                message = 'Juego finalizado.';
            }
        } else {
            message = info.isCheck ? `¡Jaque para el rey ${playerColor === 'white' ? 'negro' : 'blanco'}!` : '';
        }
        gameStatusMessage.textContent = message;
    }
    
    function updateOpponentName(roomData) {
        const currentUserUid = auth.currentUser.uid;
        const opponentUid = roomData.players.player1 === currentUserUid ? roomData.players.player2 : roomData.players.player1;
        
        if (opponentUid) {
            database.ref('users/' + opponentUid + '/username').once('value').then(snapshot => {
                const opponentUsername = snapshot.val() || 'Oponente';
                opponentNameElement.textContent = `Oponente: ${opponentUsername}`;
            }).catch(error => {
                console.error("Error fetching opponent name:", error);
            });
        }
    }

    function updateCapturedPieces(gameInfo) {
        if (!gameInfo) {
            whiteCapturedList.innerHTML = '';
            blackCapturedList.innerHTML = '';
            return;
        }

        const whiteCaptured = gameInfo.whiteCaptured || [];
        const blackCaptured = gameInfo.blackCaptured || [];
        
        whiteCapturedList.innerHTML = whiteCaptured.map(p => `<span class="captured-piece black">${pieceSymbols[p]}</span>`).join('');
        blackCapturedList.innerHTML = blackCaptured.map(p => `<span class="captured-piece white">${pieceSymbols[p]}</span>`).join('');
    }

    leaveBtn.addEventListener('click', () => {
        if (confirm('¿Estás seguro de que quieres abandonar la sala?')) {
            leaveRoom();
        }
    });

    function leaveRoom() {
        const userUid = auth.currentUser.uid;
        roomRef.once('value').then(snapshot => {
            const roomData = snapshot.val();
            if (roomData) {
                const updates = {};
                updates[`players/player1`] = null;
                updates[`players/player2`] = null;
                return roomRef.update(updates);
            }
        }).then(() => {
            console.log('Te has salido de la sala.');
            window.location.href = 'salas.html';
        }).catch(error => {
            console.error('Error al salir de la sala:', error);
        });
    }

    offerDrawBtn.addEventListener('click', () => {
        alert('Funcionalidad de ofrecer tablas no implementada aún');
    });

    resignBtn.addEventListener('click', () => {
        if (confirm('¿Estás seguro de que quieres rendirte?')) {
            const winner = playerColor === 'white' ? 'black' : 'white';
            roomRef.update({
                'gameInfo/winner': winner,
                'gameInfo/status': 'finished'
            }).then(() => {
                console.log('Juego terminado por rendición.');
            }).catch(error => {
                console.error('Error al registrar rendición:', error);
            });
        }
    });
</script>
</body>
</html>